Class - 3
==================================
00:49:00
Topic - 1
----------------------------------
Lecture Title: Vectors & Matrices
1. Introduction to Vectors
Theory:
A vector is just a list of numbers that has both direction and magnitude.

à¦­à§‡à¦•à§à¦Ÿà¦° à¦¹à¦šà§à¦›à§‡ à¦¸à¦‚à¦–à§à¦¯à¦¾à¦° à¦à¦•à¦Ÿà¦¿ à¦¤à¦¾à¦²à¦¿à¦•à¦¾, à¦¯à¦¾ à¦¦à¦¿à¦• (Direction) à¦à¦¬à¦‚ à¦®à¦¾à¦¤à§à¦°à¦¾/à¦®à¦¾à¦¨ (Magnitude) â€” à¦à¦‡ à¦¦à§à¦‡à¦Ÿà¦¿ à¦¬à§ˆà¦¶à¦¿à¦·à§à¦Ÿà§à¦¯ à¦§à¦¾à¦°à¦£ à¦•à¦°à§‡à¥¤
à¦‰à¦¦à¦¾à¦¹à¦°à¦£ à¦¦à¦¿à§Ÿà§‡ à¦¬à§à¦à¦¿:
à¦§à¦°à¦¿, à¦à¦•à¦Ÿà¦¿ à¦­à§‡à¦•à§à¦Ÿà¦° à¦²à§‡à¦–à¦¾ à¦¹à¦²à§‹:
v=[3,4]
à¦à¦Ÿà¦¿ à§¨à¦Ÿà¦¿ à¦¸à¦‚à¦–à§à¦¯à¦¾ à¦¦à¦¿à§Ÿà§‡ à¦—à¦ à¦¿à¦¤ â€” à§© à¦à¦¬à¦‚ à§ªà¥¤
à¦à¦‡ à¦­à§‡à¦•à§à¦Ÿà¦°à§‡à¦° à¦¦à¦¿à¦• à¦¬à§‹à¦à¦¾à§Ÿ à¦¯à§‡ à¦à¦Ÿà¦¿ à¦•à§‹à¦¨ à¦¦à¦¿à¦•à§‡ à¦‡à¦™à§à¦—à¦¿à¦¤ à¦•à¦°à¦›à§‡ (à¦¯à§‡à¦®à¦¨, à¦¡à¦¾à¦¨à¦¦à¦¿à¦•à§‡ à§© à¦‡à¦‰à¦¨à¦¿à¦Ÿ à¦à¦¬à¦‚ à¦“à¦ªà¦°à§‡à¦° à¦¦à¦¿à¦•à§‡ à§ª à¦‡à¦‰à¦¨à¦¿à¦Ÿ)

----------------------------------------------------------------

à¦­à§‡à¦•à§à¦Ÿà¦° (Vector) à¦à¦¬à¦‚ à¦®à§à¦¯à¦¾à¦Ÿà§à¦°à¦¿à¦•à§à¦¸ (Matrix)â€“à¦à¦° à¦¬à¦¿à¦¸à§à¦¤à¦¾à¦°à¦¿à¦¤ à¦¬à¦¾à¦‚à¦²à¦¾ à¦¬à§à¦¯à¦¾à¦–à§à¦¯à¦¾ à¦“ à¦‰à¦¦à¦¾à¦¹à¦°à¦£ à¦¦à§‡à¦“à§Ÿà¦¾ à¦¹à¦²à§‹:
ðŸ”· à¦­à§‡à¦•à§à¦Ÿà¦° (Vector)
ðŸ“Œ à¦¸à¦‚à¦œà§à¦žà¦¾:

à¦­à§‡à¦•à§à¦Ÿà¦° à¦¹à¦²à§‹ à¦à¦•à¦Ÿà¦¿ à¦¸à¦‚à¦–à§à¦¯à¦¾à¦° à¦•à§à¦°à¦®à¦¾à¦¨à§à¦¸à¦¾à¦°à§‡ à¦¸à¦¾à¦œà¦¾à¦¨à§‹ à¦¤à¦¾à¦²à¦¿à¦•à¦¾, à¦¯à¦¾à¦° à¦¦à¦¿à¦• (Direction) à¦à¦¬à¦‚ à¦®à¦¾à¦¤à§à¦°à¦¾/à¦®à¦¾à¦¨ (Magnitude) à¦¥à¦¾à¦•à§‡à¥¤ à¦à¦Ÿà¦¿ à¦à¦•à¦¾à¦§à¦¿à¦• à¦®à¦¾à¦¤à§à¦°à¦¾à§Ÿ (1D, 2D, 3D) à¦¹à¦¤à§‡ à¦ªà¦¾à¦°à§‡à¥¤
ðŸ§ª à¦‰à¦¦à¦¾à¦¹à¦°à¦£:
âœ… à§§-à¦®à¦¾à¦¤à§à¦°à¦¿à¦• à¦­à§‡à¦•à§à¦Ÿà¦° (1D):
vâƒ—=[5]
v
=[5]
âœ… à§¨-à¦®à¦¾à¦¤à§à¦°à¦¿à¦• à¦­à§‡à¦•à§à¦Ÿà¦° (2D):
vâƒ—=[3,4]
v
=[3,4]
âœ… à§©-à¦®à¦¾à¦¤à§à¦°à¦¿à¦• à¦­à§‡à¦•à§à¦Ÿà¦° (3D):
vâƒ—=[2,âˆ’1,6]
v
=[2,âˆ’1,6]
ðŸ‘‰ Python à¦•à§‹à¦¡:

import numpy as np

v1 = np.array([3, 4])         # 2D vector
v2 = np.array([2, -1, 6])     # 3D vector

ðŸ”¶ à¦®à§à¦¯à¦¾à¦Ÿà§à¦°à¦¿à¦•à§à¦¸ (Matrix)
ðŸ“Œ à¦¸à¦‚à¦œà§à¦žà¦¾:

à¦®à§à¦¯à¦¾à¦Ÿà§à¦°à¦¿à¦•à§à¦¸ à¦¹à¦šà§à¦›à§‡ à¦¸à¦‚à¦–à§à¦¯à¦¾à¦° à¦à¦•à¦Ÿà¦¿ à¦†à§Ÿà¦¤à¦¾à¦•à¦¾à¦° à¦¬à¦¿à¦¨à§à¦¯à¦¾à¦¸ à¦¬à¦¾ à¦Ÿà§‡à¦¬à¦¿à¦², à¦¯à¦¾ à¦¸à¦¾à¦°à¦¿ (rows) à¦“ à¦¸à§à¦¤à¦®à§à¦­ (columns) à¦¦à§à¦¬à¦¾à¦°à¦¾ à¦—à¦ à¦¿à¦¤à¥¤
ðŸ§ª à¦‰à¦¦à¦¾à¦¹à¦°à¦£:
âœ… à§¨Ã—à§¨ à¦®à§à¦¯à¦¾à¦Ÿà§à¦°à¦¿à¦•à§à¦¸:
A=	[1	2
	 3	4]

âœ… à§©Ã—à§¨ à¦®à§à¦¯à¦¾à¦Ÿà§à¦°à¦¿à¦•à§à¦¸:
B=	[5	6
	 7	8
	 9	10]
â€‹
ðŸ‘‰ Python à¦•à§‹à¦¡:

A = np.array([[1, 2], [3, 4]])         # 2x2 matrix
B = np.array([[5, 6], [7, 8], [9, 10]]) # 3x2 matrix

ðŸ§  à¦­à§‡à¦•à§à¦Ÿà¦° à¦¬à¦¨à¦¾à¦® à¦®à§à¦¯à¦¾à¦Ÿà§à¦°à¦¿à¦•à§à¦¸ à¦ªà¦¾à¦°à§à¦¥à¦•à§à¦¯:
à¦¬à¦¿à¦·à§Ÿ	à¦­à§‡à¦•à§à¦Ÿà¦° (Vector)	à¦®à§à¦¯à¦¾à¦Ÿà§à¦°à¦¿à¦•à§à¦¸ (Matrix)
à¦—à¦ à¦¨	à¦¶à§à¦§à§à¦®à¦¾à¦¤à§à¦° à§§à¦Ÿà¦¿ à¦¸à¦¾à¦°à¦¿ à¦¬à¦¾ à§§à¦Ÿà¦¿ à¦¸à§à¦¤à¦®à§à¦­	à¦à¦•à¦¾à¦§à¦¿à¦• à¦¸à¦¾à¦°à¦¿ à¦“ à¦¸à§à¦¤à¦®à§à¦­
à¦®à¦¾à¦¤à§à¦°à¦¾	1D, 2D, 3D...	2D (à¦¸à¦¾à¦°à¦¿ Ã— à¦¸à§à¦¤à¦®à§à¦­)
à¦‰à¦¦à¦¾à¦¹à¦°à¦£	[3,4,5][3,4,5]	[1234][13â€‹24â€‹]
à¦¬à§à¦¯à¦¬à¦¹à¦¾à¦°	à¦¦à¦¿à¦• à¦“ à¦—à¦¤à¦¿ à¦ªà§à¦°à¦•à¦¾à¦¶à§‡	à¦²à¦¿à¦¨à¦¿à§Ÿà¦¾à¦° à¦Ÿà§à¦°à¦¾à¦¨à§à¦¸à¦«à¦°à¦®à§‡à¦¶à¦¨, à¦¸à¦®à§€à¦•à¦°à¦£ à¦¸à¦®à¦¾à¦§à¦¾à¦¨à§‡
ðŸ“Š à¦ªà§à¦°à§Ÿà§‹à¦— à¦•à§à¦·à§‡à¦¤à§à¦°:

    à¦­à§‡à¦•à§à¦Ÿà¦°: à¦—à¦¤à¦¿, à¦¬à¦², à¦¸à§à¦¥à¦¾à¦¨à¦¾à¦¨à§à¦¤à¦°, à¦•à¦®à§à¦ªà¦¿à¦‰à¦Ÿà¦¾à¦° à¦—à§à¦°à¦¾à¦«à¦¿à¦•à§à¦¸à§‡

    à¦®à§à¦¯à¦¾à¦Ÿà§à¦°à¦¿à¦•à§à¦¸: à¦›à¦¬à¦¿ à¦ªà§à¦°à¦¸à§‡à¦¸à¦¿à¦‚, à¦²à¦¿à¦¨à¦¿à§Ÿà¦¾à¦° à¦¸à¦¿à¦¸à§à¦Ÿà§‡à¦® à¦¸à¦®à¦¾à¦§à¦¾à¦¨, à¦®à§‡à¦¶à¦¿à¦¨ à¦²à¦¾à¦°à§à¦¨à¦¿à¦‚

-------------------------------------------------------------------------------

import numpy as np
v = np.array([3,4])
print("Vector:", v)

Result=>
Vector: [3,4]

-------------------------------------------------------------------------------

00:58:31

import numpy as nm
vector_example = nm.array([7,11,56,89])
print('Vector_example: ', vector_example)

Result =>

Vector_example:  [ 7 11 56 89]

-------------------------------------------------------------------------------
01:00:00

vector_example = [
    [7,11,56,89],
    [8,9],
    [2,4],
    [10,4,6,9,0],
    [1]
]
print('Vector_example:', vector_example)

Result =>

Vector_example: [[7, 11, 56, 89], [8, 9], [2, 4], [10, 4, 6, 9, 0], [1]]

it is 5*n
---------

-------------------------------------------------------------------------------
Example of 2D list
------------------
Dimention

import numpy as np
arr = np.array([
    [7,11,56,89,0],
    [8,9,0,0,0],
    [2,4,0,0,0],
    [10,4,6,9,0],
    [1,0,0,0,0]
])
print(arr.ndim)

Result =>
2

This is the example of 2 dimension

-------------------------------------------------------------------------------
Checking for Dimention
----------------------
01:06:00

vector_example = [
    [7,11,56,89],
    [8,9],
    [2,4],
    [10,4,6,9,0],
    [1]
]

print('Vector_example:', vector_example)

print("Length of outer list:", len(vector_example))
print("Length of each sub-list:", [len(sublist) for sublist in vector_example])

arr = np.array(vector_example, dtype=object)
print("Array shape:", arr.shape)

Result =>

Vector_example: [[7, 11, 56, 89], [8, 9], [2, 4], [10, 4, 6, 9, 0], [1]]
Length of outer list: 5
Length of each sub-list: [4, 2, 2, 5, 1]
Array shape: (5,)

----------------------------------------------

vector_example = [
    [7,11],
    [8,9],
    [2,4],
    [10,4],
    [11,2]
]

print('Vector_example:', vector_example)

print("Length of outer list:", len(vector_example))
print("Length of each sub-list:", [len(sublist) for sublist in vector_example])

arr = np.array(vector_example, dtype=object)
print("Array shape:", arr.shape)

Result =>

Vector_example: [[7, 11], [8, 9], [2, 4], [10, 4], [11, 2]]
Length of outer list: 5
Length of each sub-list: [2, 2, 2, 2, 2]
Array shape: (5, 2)

----------------------------

vector_example = [
    [7,11,2],
    [8,9,2],
    [2,4,2],
    [10,4,3],
    [11,2,5]
]

print('Vector_example:', vector_example)

print("Length of outer list:", len(vector_example))
print("Length of each sub-list:", [len(sublist) for sublist in vector_example])

arr = np.array(vector_example, dtype=object)
print("Array shape:", arr.shape)

Result =>

Vector_example: [[7, 11, 2], [8, 9, 2], [2, 4, 2], [10, 4, 3], [11, 2, 5]]
Length of outer list: 5
Length of each sub-list: [3, 3, 3, 3, 3]
Array shape: (5, 3)

=====================================================================================================================================================

Topic - 2
===========
Vector addition and scalar multiplication
01:27:00

a = np.array([1,2])
b = np.array([2,3])

print(type(a))
print(type(b))

sum_vector = a + b
print("Sum :", sum_vector)

scaled_vector = 3 * a
print("Scaled A :", scaled_vector)

scaled_vector = 3 * b
print("Scaled B :", scaled_vector)

Result =>
<class 'numpy.ndarray'>
<class 'numpy.ndarray'>
Sum : [3 5]
Scaled A : [3 6]
Scaled B : [6 9]

Because -----

sum_vector = vector_p + vector_q

This performs element-wise addition:

[1 + 2, 2 + 3] â†’ [3, 5]

Output:

Sum : [3 5]

And

scaled_vector = vector_p * vector_q

This performs element-wise multiplication (not matrix multiplication!):

[1 * 2, 2 * 3] â†’ [2, 6]

Output:

Scaled : [2 6]
-------------------------------------------------------------------------------------------------------

01:30:00

When the item numbers are not same,

vector_p = np.array([4,7,8])
vector_q = np.array([7887,454])
print(type(vector_p))
print(type(vector_q))
sum_vector = vector_p + vector_q
print("Sum :", sum_vector)
scaled_vector = vector_p * vector_q
print("Scaled :", scaled_vector)

Result =>

<class 'numpy.ndarray'>
<class 'numpy.ndarray'>

ValueError                                Traceback (most recent call last)

<ipython-input-34-4d13920f9274> in <cell line: 0>()
      5 print(type(vector_q))
      6 
----> 7 sum_vector = vector_p + vector_q
      8 print("Sum :", sum_vector)
      9 

ValueError: operands could not be broadcast together with shapes (3,) (2,) 

-------------------------------------------------------------------------------------------------------
01:35:00

import numpy as np

vector_p = np.array([4, 8, 7])
vector_q = np.array([7887])

print(type(vector_p))  # <class 'numpy.ndarray'>
print(type(vector_q))  # <class 'numpy.ndarray'>

sum_vector = vector_p + vector_q
print("Sum :", sum_vector)

multiplication_of_vector = vector_p * vector_q
print("Scaled :", multiplication_of_vector)  # <-- Fixed this line

ðŸ” Explanation:
vector_p â†’ [4, 8, 7]

Shape: (3,) â†’ a 1D vector with 3 elements
vector_q â†’ [7887]

Shape: (1,) â†’ a 1D vector with 1 element
âš ï¸ What's happening here?

Even though vector_q has only one value, NumPy broadcasts that single value across the length of vector_p:

So it behaves as if you did:

[4, 8, 7] + [7887, 7887, 7887] â†’ [7891, 7895, 7894]
[4, 8, 7] * [7887, 7887, 7887] â†’ [31548, 63096, 55209]

âœ… Output:

<class 'numpy.ndarray'>
<class 'numpy.ndarray'>
Sum : [7891 7895 7894]
Scaled : [31548 63096 55209]

=====================================================================================================================================================

Topic - 3
===========
1:39:00
Dot product between vectors
Dot Product = how similar two directors are.

----------------------------

v1 = np.array([1,8,2])
v2 = np.array([3,4])
dot = np.dot(v1, v2)
print("Dot product:", dot)

Result =>

ValueError                                Traceback (most recent call last)
<ipython-input-43-fba280499316> in <cell line: 0>()
      2 v2 = np.array([3,4])
      3 
----> 4 dot = np.dot(v1, v2)
      5 print("Dot product:", dot)
ValueError: shapes (3,) and (2,) not aligned: 3 (dim 0) != 2 (dim 0)


------------------------------------------------------------------------------------------------------------------------------
When Both vectors have the same size. For example:

v1 = np.array([1, 8])
v2 = np.array([3, 4])
dot = np.dot(v1, v2)
print("Dot product:", dot)

This will compute:
1Ã—3+8Ã—4=3+32=35

Result =>
---------
Dot product: 35

------------------------------------------------------------------------------------------------------------------------------

Vector VS MAtrix
01:49:00

à¦­à§‡à¦•à§à¦Ÿà¦° (Vector) à¦à¦¬à¦‚ à¦®à§à¦¯à¦¾à¦Ÿà§à¦°à¦¿à¦•à§à¦¸ (Matrix) â€” à¦à¦‡ à¦¦à§à¦Ÿà¦¿ à¦¶à¦¬à§à¦¦ à¦—à¦£à¦¿à¦¤ à¦“ à¦ªà§à¦°à§‹à¦—à§à¦°à¦¾à¦®à¦¿à¦‚à¦¯à¦¼à§‡ à¦…à¦¨à§‡à¦• à¦—à§à¦°à§à¦¤à§à¦¬à¦ªà§‚à¦°à§à¦£à¥¤ à¦¨à¦¿à¦šà§‡ à¦¬à¦¾à¦‚à¦²à¦¾à¦¯à¦¼ à¦¸à¦¹à¦œà¦­à¦¾à¦¬à§‡ à¦à¦¦à§‡à¦° à¦ªà¦¾à¦°à§à¦¥à¦•à§à¦¯ à¦“ à¦‰à¦¦à¦¾à¦¹à¦°à¦£ à¦¤à§à¦²à§‡ à¦§à¦°à¦¾ à¦¹à¦²à§‹:
ðŸ“Œ à¦­à§‡à¦•à§à¦Ÿà¦° (Vector) à¦•à§€?
à¦­à§‡à¦•à§à¦Ÿà¦° à¦¹à¦²à§‹ à¦¸à¦‚à¦–à§à¦¯à¦¾à¦—à§à¦²à§‹à¦° à¦à¦•à¦Ÿà¦¿ à¦à¦•à¦®à¦¾à¦¤à§à¦°à¦¿à¦• (1D) à¦¤à¦¾à¦²à¦¿à¦•à¦¾ à¦¬à¦¾ à¦¬à¦¿à¦¨à§à¦¯à¦¾à¦¸à¥¤
ðŸ‘‰ à¦à¦Ÿà¦¾ à¦¹à¦¤à§‡ à¦ªà¦¾à¦°à§‡:
à¦¸à¦¾à¦°à¦¿ à¦¹à¦¿à¦¸à§‡à¦¬à§‡: [3, 5, 7]
à¦…à¦¥à¦¬à¦¾ à¦¸à§à¦¤à¦®à§à¦­ à¦¹à¦¿à¦¸à§‡à¦¬à§‡:
    	[3
	 5
	 7]
ðŸ”¹ à¦à¦Ÿà¦¿ à¦à¦•à¦Ÿà¦¿ à¦®à¦¾à¦¤à§à¦°à¦¾ (dimension) à¦¨à¦¿à¦¯à¦¼à§‡ à¦•à¦¾à¦œ à¦•à¦°à§‡ â€” à¦¶à§à¦§à§ à¦¸à¦¾à¦°à¦¿ à¦¬à¦¾ à¦¶à§à¦§à§ à¦¸à§à¦¤à¦®à§à¦­à¥¤
ðŸ§ª à¦‰à¦¦à¦¾à¦¹à¦°à¦£:

import numpy as np
v = np.array([3, 5, 7])  # à¦à¦•à¦Ÿà¦¿ à¦­à§‡à¦•à§à¦Ÿà¦°

ðŸ“Œ à¦®à§à¦¯à¦¾à¦Ÿà§à¦°à¦¿à¦•à§à¦¸ (Matrix) à¦•à§€?
à¦®à§à¦¯à¦¾à¦Ÿà§à¦°à¦¿à¦•à§à¦¸ à¦¹à¦²à§‹ à¦¸à¦‚à¦–à§à¦¯à¦¾à¦—à§à¦²à§‹à¦° à¦à¦•à¦Ÿà¦¿ à¦†à§Ÿà¦¤à¦¾à¦•à¦¾à¦° à¦¦à§à¦‡ à¦®à¦¾à¦¤à§à¦°à¦¾à¦° (2D) à¦¬à¦¿à¦¨à§à¦¯à¦¾à¦¸, à¦¯à¦¾ à¦¸à¦¾à¦°à¦¿ (rows) à¦“ à¦¸à§à¦¤à¦®à§à¦­ (columns) à¦¦à¦¿à§Ÿà§‡ à¦—à¦ à¦¿à¦¤à¥¤
ðŸ§ª à¦‰à¦¦à¦¾à¦¹à¦°à¦£:
A=	[1	2
	 3	4
	 5	6]

ðŸ”¹ à¦à¦Ÿà¦¿ à§¨à¦Ÿà¦¿ à¦¸à¦¾à¦°à¦¿ à¦“ à§©à¦Ÿà¦¿ à¦¸à§à¦¤à¦®à§à¦­ à¦¬à¦¿à¦¶à¦¿à¦·à§à¦Ÿ à¦à¦•à¦Ÿà¦¿ 2x3 à¦®à§à¦¯à¦¾à¦Ÿà§à¦°à¦¿à¦•à§à¦¸à¥¤
Python à¦:
A = np.array([
    [1, 2, 3],
    [4, 5, 6]
])

ðŸ“Š à¦­à§‡à¦•à§à¦Ÿà¦° à¦¬à¦¨à¦¾à¦® à¦®à§à¦¯à¦¾à¦Ÿà§à¦°à¦¿à¦•à§à¦¸:
à¦¬à§ˆà¦¶à¦¿à¦·à§à¦Ÿà§à¦¯		à¦­à§‡à¦•à§à¦Ÿà¦° (Vector)	à¦®à§à¦¯à¦¾à¦Ÿà§à¦°à¦¿à¦•à§à¦¸ (Matrix)
à¦®à¦¾à¦¤à§à¦°à¦¾ (Dimension)	1-à¦®à¦¾à¦¤à§à¦°à¦¿à¦• (1D)	2-à¦®à¦¾à¦¤à§à¦°à¦¿à¦• (2D)
à¦‰à¦ªà¦¸à§à¦¥à¦¾à¦ªà¦¨		à¦à¦•à¦Ÿà¦¿ à¦¸à¦¾à¦°à¦¿ à¦¬à¦¾ à¦¸à§à¦¤à¦®à§à¦­	à¦¸à¦¾à¦°à¦¿ à¦“ à¦¸à§à¦¤à¦®à§à¦­à§‡à¦° à¦†à§Ÿà¦¤à¦¾à¦•à¦¾à¦° à¦Ÿà§‡à¦¬à¦¿à¦²
à¦‰à¦¦à¦¾à¦¹à¦°à¦£		[4, 7, 9]	[[1,2], [3,4], [5,6]]
NumPy Shape	(3,)		(3, 2)
List type	Single List	List of List

ðŸ” à¦¸à¦‚à¦•à§à¦·à§‡à¦ªà§‡:
    à¦­à§‡à¦•à§à¦Ÿà¦° = à¦¶à§à¦§à§à¦®à¦¾à¦¤à§à¦° à¦à¦•à¦Ÿà¦¿ à¦²à¦¾à¦‡à¦¨ (à¦¸à¦¾à¦°à¦¿ à¦¬à¦¾ à¦¸à§à¦¤à¦®à§à¦­)
    à¦®à§à¦¯à¦¾à¦Ÿà§à¦°à¦¿à¦•à§à¦¸ = à¦¸à¦¾à¦°à¦¿ à¦“ à¦¸à§à¦¤à¦®à§à¦­à§‡ à¦—à¦ à¦¿à¦¤ à¦†à§Ÿà¦¤à¦¾à¦•à¦¾à¦° à¦¸à¦‚à¦–à§à¦¯à¦¾ à¦¬à¦¿à¦¨à§à¦¯à¦¾à¦¸

------------------------------------------------------------------------------------------------------------------------------
1:52:52

v1 = np.array([1,2])
v2 = np.array([3,4,45])

multi_of_v1v2 = v1 * v2
print("Multi of v1v2:", multi_of_v1v2)

Result =>

ValueError                                Traceback (most recent call last)
<ipython-input-4-22dcdc8cc122> in <cell line: 0>()
      2 v2 = np.array([3,4,45])
      3 
----> 4 multi_of_v1v2 = v1 * v2
      5 print("Multi of v1v2:", multi_of_v1v2)
ValueError: operands could not be broadcast together with shapes (2,) (3,) 
------------------------------------------------------------------------------------------------------------------------------
1:54:00
Matrix Multiplication

v1 = np.array([1,2,5])
v2 = np.array([3,4,45])

m1 = np.array(
    [
        [1,2]
    ]
)
m2 = np.array(
    [
        [1,2]
    ]
)
multi_of_v1v2 = v1 * v2
print("Multi of v1v2:", multi_of_v1v2)

multi_of_m1m2 = m1 * m2
print("Multi of m1m2:", multi_of_m1m2)

Result =>
Multi of v1v2: [  3   8 225]
Multi of m1m2: [[1 4]]

------------------------------------------------------------------------------------------------------------------------------

m1 = np.array(
    [
        [1,3]
    ]
)
m2 = np.array(
    [
        [1,2]
    ]
)

dot = np.dot(m1, m2)
print("Dot product:", dot)

Result =>
ValueError                                Traceback (most recent call last)
<ipython-input-15-01a9cd4b6ffd> in <cell line: 0>()
     13 )
     14 
---> 15 dot = np.dot(m1, m2)
     16 print("Dot product:", dot)
ValueError: shapes (1,2) and (1,2) not aligned: 2 (dim 1) != 1 (dim 0)
--------------------------------------------------------------------------------------------------
à¦†à¦ªà¦¨à¦¾à¦° à¦•à§‹à¦¡à§‡ à¦¯à§‡ ValueError à¦à¦¸à§‡à¦›à§‡, à¦¸à§‡à¦Ÿà¦¾ à¦¹à¦šà§à¦›à§‡ matrix dot product à¦•à¦°à¦¤à§‡ à¦—à§‡à¦²à§‡ shape mismatch à¦¬à¦¾ shape alignment errorà¥¤
ðŸ” Error à¦¬à§à¦¯à¦¾à¦–à§à¦¯à¦¾:
ValueError: shapes (1,2) and (1,2) not aligned: 2 (dim 1) != 1 (dim 0)
à¦à¦° à¦®à¦¾à¦¨à§‡:
    m1 à¦à¦° shape: (1, 2) â†’ à§§ à¦¸à¦¾à¦°à¦¿, à§¨ à¦•à¦²à¦¾à¦®
    m2 à¦à¦° shape: (1, 2) â†’ à§§ à¦¸à¦¾à¦°à¦¿, à§¨ à¦•à¦²à¦¾à¦®
Dot product à¦¬à¦¾ matrix multiplication à¦•à¦°à¦¤à§‡ à¦¹à¦²à§‡ m1-à¦à¦° à¦•à¦²à¦¾à¦®à§‡à¦° à¦¸à¦‚à¦–à§à¦¯à¦¾ = m2-à¦à¦° à¦¸à¦¾à¦°à¦¿à¦° à¦¸à¦‚à¦–à§à¦¯à¦¾ à¦¹à¦“à¦¯à¦¼à¦¾ à¦²à¦¾à¦—à¦¬à§‡à¥¤
âŒ à¦à¦–à¦¾à¦¨à§‡: 2 â‰  1 â†’ à¦¤à¦¾à¦‡ dot product à¦¸à¦®à§à¦­à¦¬ à¦¨à¦¾à¥¤

âœ… à¦¸à¦®à¦¾à¦§à¦¾à¦¨:
à¦†à¦ªà¦¨à¦¾à¦° à¦¯à¦¦à¦¿ m2-à¦•à§‡ à¦¸à¦ à¦¿à¦•à¦­à¦¾à¦¬à§‡ à¦®à§à¦¯à¦¾à¦Ÿà§à¦°à¦¿à¦•à§à¦¸ à¦—à¦ à¦¨ à¦•à¦°à¦¤à§‡ à¦¹à¦¯à¦¼, à¦¤à¦¾à¦¹à¦²à§‡ transpose à¦•à¦°à¦¤à§‡ à¦¹à¦¬à§‡ à¦¯à§‡à¦¨ shape (2, 1) à¦¹à¦¯à¦¼à¥¤
âœ”ï¸ à¦ à¦¿à¦• à¦•à¦°à¦¾ à¦•à§‹à¦¡:
import numpy as np
m1 = np.array([[1, 3]])
m2 = np.array([[1, 2]])
# Transpose m2 to make dot product possible
dot = np.dot(m1, m2.T)
print("Dot product:", dot)
âœ… Output:
Dot product: [[7]]
--------------------------------------------------------------------------------------------------
02:01:24
Difference between dot product and mulplications

Great question! In NumPy, the terms "multiplication" and "dot product" often confuse beginners because they behave differently depending on context.
Letâ€™s break this down in simple terms with examples and in Bangla too.
ðŸ”¹ 1. Multiplication (*) â€” Element-wise à¦—à§à¦£
ðŸ‘‰ à¦à¦Ÿà¦¿ à¦ªà§à¦°à¦¤à¦¿à¦Ÿà¦¿ à¦‰à¦ªà¦¾à¦¦à¦¾à¦¨à¦•à§‡ à¦à¦•à¦‡ à¦…à¦¬à¦¸à§à¦¥à¦¾à¦¨à§‡à¦° à¦‰à¦ªà¦¾à¦¦à¦¾à¦¨à§‡à¦° à¦¸à¦¾à¦¥à§‡ à¦—à§à¦£ à¦•à¦°à§‡à¥¤
âœ… à¦‰à¦¦à¦¾à¦¹à¦°à¦£:
import numpy as np
a = np.array([1, 2, 3])
b = np.array([4, 5, 6])
print(a * b)
ðŸ“¤ Output:
[ 4 10 18 ]
ðŸ”¸ à¦•à¦¾à¦°à¦£:
1Ã—4 = 4
2Ã—5 = 10
3Ã—6 = 18
âž¡ï¸ à¦à¦•à§‡ à¦¬à¦²à§‡ Element-wise multiplication
âž¡ï¸ à¦à¦Ÿà¦¿ matrix multiplication à¦¨à¦¾, à¦¬à¦°à¦‚ à¦ªà§à¦°à¦¤à¦¿à¦Ÿà¦¿ à¦‰à¦ªà¦¾à¦¦à¦¾à¦¨ à¦†à¦²à¦¾à¦¦à¦¾à¦­à¦¾à¦¬à§‡ à¦—à§à¦£ à¦¹à§Ÿà¥¤
ðŸ”¹ 2. Dot Product (np.dot() / @) â€” à¦—à¦¾à¦£à¦¿à¦¤à¦¿à¦• à¦¡à¦Ÿ à¦—à§à¦£à¦«à¦²
ðŸ‘‰ à¦à¦Ÿà¦¿ à¦­à§‡à¦•à§à¦Ÿà¦° à¦¬à¦¾ à¦®à§à¦¯à¦¾à¦Ÿà§à¦°à¦¿à¦•à§à¦¸à§‡à¦° à¦¡à¦Ÿ à¦ªà§à¦°à§‹à¦¡à¦¾à¦•à§à¦Ÿ à¦¬à¦¾ à¦®à§à¦¯à¦¾à¦Ÿà§à¦°à¦¿à¦•à§à¦¸ à¦®à¦¾à¦²à§à¦Ÿà¦¿à¦ªà§à¦²à¦¿à¦•à§‡à¦¶à¦¨ à¦•à¦°à§‡à¥¤
âœ… à¦‰à¦¦à¦¾à¦¹à¦°à¦£ (Vectors):
a = np.array([1, 2, 3])
b = np.array([4, 5, 6])
print(np.dot(a, b))
ðŸ“¤ Output:
32
ðŸ”¸ à¦•à¦¾à¦°à¦£:
(1Ã—4) + (2Ã—5) + (3Ã—6) = 4 + 10 + 18 = 32
âž¡ï¸ à¦à¦•à§‡ à¦¬à¦²à§‡ Dot Product
âž¡ï¸ à¦à¦Ÿà¦¿ à¦à¦•à¦Ÿà¦¿ à¦¸à¦‚à¦–à§à¦¯à¦¾ (scalar) à¦¦à§‡à¦¯à¦¼
âœ… à¦‰à¦¦à¦¾à¦¹à¦°à¦£ (Matrices):
m1 = np.array([[1, 2], [3, 4]])
m2 = np.array([[5, 6], [7, 8]])
print(np.dot(m1, m2))
ðŸ“¤ Output:
[[19 22]
 [43 50]]
ðŸ”¸ à¦à¦–à¦¾à¦¨à§‡ m1 à¦¹à¦² (2Ã—2), m2-à¦“ (2Ã—2) â€” à¦¤à¦¾à¦‡ dot product/à¦®à§à¦¯à¦¾à¦Ÿà§à¦°à¦¿à¦•à§à¦¸ à¦—à§à¦£à¦«à¦² à¦¸à¦®à§à¦­à¦¬à¥¤
ðŸ” à¦¤à§à¦²à¦¨à¦¾: Multiplication vs Dot Product
à¦¬à§ˆà¦¶à¦¿à¦·à§à¦Ÿà§à¦¯		* (Multiplication)	np.dot() à¦¬à¦¾ @ (Dot Product)
----		------------------	-----------------------------------
à¦¨à¦¾à¦®		Element-wise à¦—à§à¦£		Dot Product / Matrix Multiplication
à¦ªà§à¦°à§Ÿà§‹à¦— à¦¹à§Ÿ à¦•à¦¿à¦­à¦¾à¦¬à§‡?	à¦à¦•à¦‡ shape à¦à¦° à¦‰à¦ªà¦¾à¦¦à¦¾à¦¨ à¦—à§à¦¨à§‡	à¦—à¦£à¦¿à¦¤ à¦…à¦¨à§à¦¯à¦¾à§Ÿà§€ row Ã— column à¦—à§à¦¨à§‡
à¦†à¦‰à¦Ÿà¦ªà§à¦Ÿ à¦¹à§Ÿ à¦•à§€?	à¦à¦•à¦‡ shape à¦à¦° array	Scalar à¦¬à¦¾ à¦¨à¦¤à§à¦¨ à¦®à§à¦¯à¦¾à¦Ÿà§à¦°à¦¿à¦•à§à¦¸
à¦‰à¦¦à¦¾à¦¹à¦°à¦£		[1,2] * [3,4] â†’ [3,8]	dot([1,2], [3,4]) â†’ 1Ã—3 + 2Ã—4 = 11
ðŸ§ª à¦‰à¦ªà¦¸à¦‚à¦¹à¦¾à¦°:
    âœ… * â†’ à¦¶à§à¦§à§ à¦‰à¦ªà¦¾à¦¦à¦¾à¦¨ à¦—à§à¦£ (à¦¯à¦¦à¦¿ à¦†à¦•à¦¾à¦° à¦®à§‡à¦²à§‡)
    âœ… np.dot() â†’ à¦—à¦£à¦¿à¦¤à§‡à¦° à¦®à¦¤à§‹ à¦†à¦¸à¦² à¦¡à¦Ÿ à¦ªà§à¦°à§‹à¦¡à¦¾à¦•à§à¦Ÿ à¦¬à¦¾ à¦®à§à¦¯à¦¾à¦Ÿà§à¦°à¦¿à¦•à§à¦¸ à¦—à§à¦£

-----------------------------------------------------------------------------------------------------------------------------------------------
02:05:33

# Matrix A: 2X3
A = np.array([
    [1, 2, 3],
    [4, 5, 6]
])

# Matrix B: 3X2
B = np.array([
    [7, 8],
    [9, 10],
    [11, 12]
])

# Matrix Mulplication (dot product of matrices)
result = np.dot(A, B)
print("Matrix A:")
print(A)
print("\nMatrix B:")
print(B)
print("\nMatrix Multiplication Result:\n", result)

Result=>
--------

Matrix A:
[[1 2 3]
 [4 5 6]]

Matrix B:
[[ 7  8]
 [ 9 10]
 [11 12]]

Matrix Multiplication Result:
 [[ 58  64]
 [139 154]]

ðŸŽ¯ à¦•à¦¿à¦­à¦¾à¦¬à§‡ à¦¹à¦¿à¦¸à¦¾à¦¬ à¦¹à¦²à§‹:
Result[0][0]=1Ã—7+2Ã—9+3Ã—11=7+18+33=58
Result[0][1]=1Ã—8+2Ã—10+3Ã—12=8+20+36=64
Result[1][0]=4Ã—7+5Ã—9+6Ã—11=28+45+66=139
Result[1][1]=4Ã—8+5Ã—10+6Ã—12=32+50+72=154
----------------------------------------------------------------------------------------------------------------------------------------------
02:13:25

# Matrix A: 2X3
A = np.array([
    [1, 2, 3],
    [4, 5, 6]
])

# Matrix B: 3X2
B = np.array([
    [7, 8],
    [9, 10],
    [11, 12]
])

# Matrix Mulplication (dot product of matrices)
matrix_multiplication_result = A * B
print("Result:\n", matrix_multiplication_result)

matrix_dot_result = np.dot(A, B)
print("Result:\n", matrix_dot_result)

Result=>

ValueError                                Traceback (most recent call last)
<ipython-input-19-c960c17e26fa> in <cell line: 0>()
     13 
     14 # Matrix Mulplication (dot product of matrices)
---> 15 matrix_multiplication_result = A * B
     16 print("Result:\n", matrix_multiplication_result)
     17 
ValueError: operands could not be broadcast together with shapes (2,3) (3,2) 

à¦à¦–à¦¾à¦¨à§‡ à¦†à¦ªà¦¨à¦¿ * à¦¬à§à¦¯à¦¬à¦¹à¦¾à¦° à¦•à¦°à¦›à§‡à¦¨, à¦¯à¦¾ element-wise multiplication à¦•à¦°à¦¤à§‡ à¦šà¦¾à§Ÿ, à¦•à¦¿à¦¨à§à¦¤à§ A à¦à¦¬à¦‚ B à¦à¦° shape à¦à¦• à¦¨à§Ÿ:
    A.shape = (2, 3)
    B.shape = (3, 2)
âš ï¸ à¦¤à¦¾à¦‡ A * B à¦šà¦¾à¦²à¦¾à¦¤à§‡ à¦—à§‡à¦²à§‡ à¦à¦‡ à¦­à§à¦² à¦†à¦¸à¦¬à§‡:
ValueError: operands could not be broadcast together with shapes (2,3) (3,2)

ðŸ“Š à¦‰à¦ªà¦¸à¦‚à¦¹à¦¾à¦°:
à¦…à¦ªà¦¾à¦°à§‡à¦¶à¦¨		à¦¬à§à¦¯à¦¾à¦–à§à¦¯à¦¾			Valid	à¦¬à§à¦¯à¦¾à¦–à§à¦¯à¦¾
A * B		Element-wise à¦—à§à¦£		âŒ	à¦†à¦•à¦¾à¦° à¦®à§‡à¦²à§‡ à¦¨à¦¾
np.dot(A, B)	Matrix multiplication	âœ…	A(2x3) Ã— B(3x2) â†’ (2x2)

----------------------------------------------------------------------------------------------------------------------------------------------

02:23:00

vector_matrix_example_a = [
    [7,11,56,89],
    [8,9],
    [2,4],
    [10,4,6,9,0],
    [1]
]

vector_matrix_example_b = [
    [7,11,56,89],
    [8,9],
    [2,4],
    [10,4,6,9,0],
    [1]
]

print(vector_matrix_example_a + vector_matrix_example_b)

Result =>

[[7, 11, 56, 89], [8, 9], [2, 4], [10, 4, 6, 9, 0], [1], [7, 11, 56, 89], [8, 9], [2, 4], [10, 4, 6, 9, 0], [1]]

print(vector_matrix_example_a * vector_matrix_example_b)

Result = >

---------------------------------------------------------------------------

TypeError                                 Traceback (most recent call last)
<ipython-input-21-9f2aae896ca2> in <cell line: 0>()
----> 1 print(vector_matrix_example_a * vector_matrix_example_b)
TypeError: can't multiply sequence by non-int of type 'list'

----------------------------------------------------------------------------------------------------------------------------------------------

02:30:00

vector_example = [
    [7,11,56,89],
    [8,9],
    [2,4],
    [10,4,6,9,0],
    [1]
]

arr = np.array(vector_example, dtype=object)
print("Array shape:", arr.shape)
print(arr)

print(vector_example)
shape_of_vector_example = np.array(vector_example)
print(shape_of_vector_example)

Result =>

Array shape: (5,)
[list([7, 11, 56, 89]) list([8, 9]) list([2, 4]) list([10, 4, 6, 9, 0])
 list([1])]
[[7, 11, 56, 89], [8, 9], [2, 4], [10, 4, 6, 9, 0], [1]]

---------------------------------------------------------------------------

ValueError                                Traceback (most recent call last)

<ipython-input-23-d9eefd80ca55> in <cell line: 0>()
     12 
     13 print(vector_example)
---> 14 shape_of_vector_example = np.array(vector_example)
     15 print(shape_of_vector_example)

ValueError: setting an array element with a sequence. The requested array has an inhomogeneous shape after 1 dimensions. The detected shape was (5,) + inhomogeneous part.

----------------------------------------------------------------------------------------------------------------------------------------------

à¦†à¦ªà¦¨à¦¾à¦° à¦•à§‹à¦¡à¦Ÿà¦¿ à¦œà¦Ÿà¦¿à¦² nested list à¦¬à§à¦¯à¦¬à¦¹à¦¾à¦° à¦•à¦°à¦›à§‡ à¦¯à§‡à¦–à¦¾à¦¨à§‡ à¦ªà§à¦°à¦¤à¦¿à¦Ÿà¦¿ à¦‰à¦ª-à¦¤à¦¾à¦²à¦¿à¦•à¦¾à¦° à¦¦à§ˆà¦°à§à¦˜à§à¦¯ à¦¸à¦®à¦¾à¦¨ à¦¨à§Ÿ â€” à¦à¦•à§‡ à¦¬à¦²à§‡ ragged array à¦¬à¦¾ inhomogeneous listà¥¤ à¦¨à¦¿à¦šà§‡ à¦¬à§à¦¯à¦¾à¦–à§à¦¯à¦¾ à¦¸à¦¹ à¦«à¦²à¦¾à¦«à¦² à¦¦à§‡à¦“à§Ÿà¦¾ à¦¹à¦²à§‹:
ðŸ”¸ à¦•à§‹à¦¡ à¦¬à§à¦¯à¦¾à¦–à§à¦¯à¦¾:
vector_example = [
    [7,11,56,89],
    [8,9],
    [2,4],
    [10,4,6,9,0],
    [1]
]
arr = np.array(vector_example, dtype=object)
print("Array shape:", arr.shape)
print(arr)
print(vector_example)
shape_of_vector_example = np.array(vector_example)
print(shape_of_vector_example)

ðŸ§  à¦•à§€ à¦¹à¦šà§à¦›à§‡ à¦à¦–à¦¾à¦¨à§‡:
âœ… à§§. np.array(vector_example, dtype=object):
à¦à¦–à¦¾à¦¨à§‡ à¦†à¦ªà¦¨à¦¿ dtype=object à¦¦à¦¿à§Ÿà§‡à¦›à§‡à¦¨, à¦¤à¦¾à¦‡ NumPy à¦¬à§à¦à§‡ à¦—à§‡à¦›à§‡ à¦ªà§à¦°à¦¤à¦¿à¦Ÿà¦¿ à¦‰à¦ª-à¦¤à¦¾à¦²à¦¿à¦•à¦¾ à¦†à¦²à¦¾à¦¦à¦¾ à¦¦à§ˆà¦°à§à¦˜à§à¦¯à§‡à¦° â€” à¦à¦¬à¦‚ à¦à¦Ÿà¦¾à¦•à§‡ à¦à¦•à¦Ÿà¦¿ 1D object array à¦¬à¦¾à¦¨à¦¿à§Ÿà§‡à¦›à§‡:
Array shape: (5,)
ðŸ”¸ à¦…à¦°à§à¦¥à¦¾à§Ž à¦à¦Ÿà¦¿ à¦à¦•à¦Ÿà¦¿ 1D array, à¦¯à¦¾à¦° à¦ªà§à¦°à¦¤à¦¿à¦Ÿà¦¿ à¦‰à¦ªà¦¾à¦¦à¦¾à¦¨ à¦à¦•à¦Ÿà¦¿ Python listà¥¤
âš ï¸ à§¨. np.array(vector_example) (without dtype=object):
à¦à¦–à¦¾à¦¨à§‡ NumPy à¦šà§‡à¦·à§à¦Ÿà¦¾ à¦•à¦°à§‡ à¦à¦•à¦Ÿà¦¿ regular array à¦¬à¦¾à¦¨à¦¾à¦¤à§‡à¥¤ à¦•à¦¿à¦¨à§à¦¤à§ à¦¯à§‡à¦¹à§‡à¦¤à§ à¦‰à¦ª-à¦¤à¦¾à¦²à¦¿à¦•à¦¾à¦—à§à¦²à§‹à¦° à¦¦à§ˆà¦°à§à¦˜à§à¦¯ à¦­à¦¿à¦¨à§à¦¨, à¦¤à¦¾à¦‡ NumPy fallback à¦•à¦°à§‡ object array-à¦¤à§‡ à¦à¦¬à¦‚ warning à¦¦à§‡à¦–à¦¾à¦¤à§‡ à¦ªà¦¾à¦°à§‡à¥¤
âœ… Output (à¦¸à¦ à¦¿à¦•à¦­à¦¾à¦¬à§‡):
Array shape: (5,)
[list of variable lengths...]
à¦ªà§à¦°à¦¤à¦¿à¦Ÿà¦¿ à¦‰à¦ªà¦¾à¦¦à¦¾à¦¨ à¦†à¦¸à¦²à§‡ à¦à¦•à§‡à¦•à¦Ÿà¦¾ list:
    [7,11,56,89]
    [8,9]
    ...
ðŸ“Œ à¦‰à¦ªà¦¸à¦‚à¦¹à¦¾à¦°:
à¦ªà§à¦°à¦¶à§à¦¨					à¦‰à¦¤à§à¦¤à¦°
vector_example à¦•à¦¿ 2D array?		âŒ à¦¨à¦¾, à¦•à¦¾à¦°à¦£ à¦ªà§à¦°à¦¤à¦¿à¦Ÿà¦¿ row-à¦à¦° size à¦à¦• à¦¨à¦¾
à¦à¦° shape à¦•à§€?				(5,) â€” à¦…à¦°à§à¦¥à¦¾à§Ž à§«à¦Ÿà¦¿ à¦‰à¦ªà¦¾à¦¦à¦¾à¦¨ à¦¬à¦¿à¦¶à¦¿à¦·à§à¦Ÿ à§§-à¦®à¦¾à¦¤à§à¦°à¦¿à¦• object array
à¦•à§€à¦­à¦¾à¦¬à§‡ à¦à¦Ÿà¦¾ à¦¸à¦®à¦¾à¦¨ à¦¦à§ˆà¦°à§à¦˜à§à¦¯à§‡à¦° 2D array à¦¬à¦¾à¦¨à¦¾à¦¨à§‹ à¦¯à¦¾à§Ÿ?		à¦¸à¦•à¦² row à¦à¦° à¦¦à§ˆà¦°à§à¦˜à§à¦¯ à¦¸à¦®à¦¾à¦¨ à¦•à¦°à¦¤à§‡ à¦¹à¦¬à§‡

---------------------------------------------------------------------------------------------------------------------------------------------

A = np.array([1, 2, 3])
B = np.array([4, 5])
print(A + B)  # This will raise an error

Result =>
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
Cell In[2], line 3
      1 A = np.array([1, 2, 3])
      2 B = np.array([4, 5])
----> 3 print(A + B)  # This will raise an error

ValueError: operands could not be broadcast together with shapes (3,) (2,) 

>à¦¤à§à¦®à¦¿ à¦¯à¦¦à¦¿ à§©à¦Ÿà¦¾ à¦†à¦® à¦¨à¦¾à¦“ à¦†à¦° à¦†à¦®à¦¿ à§¨à¦Ÿà¦¾, à¦¤à¦¾à¦¹à¦²à§‡ à¦ªà§à¦°à¦¤à¦¿à¦Ÿà¦¿à¦° à¦¸à¦™à§à¦—à§‡ à¦œà§‹à¦¡à¦¼à¦¾ à¦•à¦°à¦¾ à¦¯à¦¾à¦¬à§‡ à¦¨à¦¾à¥¤
Explanation:
Each position in one vector must match a position in the other to add. No extra or missing values allowed.

----------------------------------------------------------------------------------------------------------------------------------------------

A = np.array([[1, 2], [3, 4]])
B = np.array([[5, 6, 7]])
print(A + B)  # Error due to shape mismatch

Result =>

---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
Cell In[4], line 3
      1 A = np.array([[1, 2], [3, 4]])
      2 B = np.array([[5, 6, 7]])
----> 3 print(A + B)  # Error due to shape mismatch

ValueError: operands could not be broadcast together with shapes (2,2) (1,3) 

>à¦¯à¦¦à¦¿ à¦¦à§à¦Ÿà¦¿ à¦•à§à¦²à¦¾à¦¸à§‡à¦° à¦°à§‹à¦² à¦¨à¦®à§à¦¬à¦° à¦¤à¦¾à¦²à¦¿à¦•à¦¾à¦° à¦°à§‹ à¦à¦¬à¦‚ à¦•à¦²à¦¾à¦® à¦¨à¦¾ à¦®à¦¿à¦²à§‡, à¦¤à¦¾à¦¹à¦²à§‡ à¦à¦•à¦¸à¦¾à¦¥à§‡ à¦¯à§‹à¦— à¦•à¦°à¦¾ à¦¯à¦¾à¦¬à§‡ à¦¨à¦¾à¥¤
Explanation:
Matrix addition is element-wise: each cell in one matrix must match with a cell in the same position in the other.

----------------------------------------------------------------------------------------------------------------------------------------------

A = np.array([1, 2, 3])
B = np.array([4, 5])
print(A * B)  # Error

Result =>
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
<ipython-input-29-f7fb88083e98> in <cell line: 0>()
      1 A = np.array([1, 2, 3])
      2 B = np.array([4, 5])
----> 3 print(A * B)  # Error
ValueError: operands could not be broadcast together with shapes (3,) (2,) 

à¦¯à¦¦à¦¿ à¦¤à§‹à¦®à¦¾à¦° à¦†à¦° à¦†à¦®à¦¾à¦° à¦¤à¦¿à¦¨ à¦¦à¦¿à¦¨ à¦•à¦°à§‡ à¦•à¦¾à¦œ à¦¥à¦¾à¦•à§‡, à¦•à¦¿à¦¨à§à¦¤à§ à¦à¦•à¦œà¦¨à§‡à¦° à¦¦à§à¦‡ à¦¦à¦¿à¦¨à¦‡ à¦•à¦¾à¦œ à¦¥à¦¾à¦•à§‡, à¦¤à¦¾à¦¹à¦²à§‡ à¦ªà§à¦°à¦¤à¦¿à¦¦à¦¿à¦¨ à¦—à§à¦£ à¦•à¦°à§‡ à¦¹à¦¿à¦¸à¦¾à¦¬ à¦•à¦°à¦¾ à¦¯à¦¾à¦¬à§‡ à¦¨à¦¾à¥¤
ðŸ“˜ Explanation:
This is just like multiplying matching values in two lists. If one list is shorter, there's no match for the extra values.

----------------------------------------------------------------------------------------------------------------------------------------------
## âœ… 4. Matrix Element-wise Multiplication :

A = np.array([[1, 2], [3, 4]])
B = np.array([[5, 6, 7]])
print(A * B)  # Error

Result =>

ValueError                                Traceback (most recent call last)
<ipython-input-32-0bd9cd52b368> in <cell line: 0>()
      1 A = np.array([[1, 2], [3, 4]])
      2 B = np.array([[5, 6, 7]])
----> 3 print(A * B)  # Error
ValueError: operands could not be broadcast together with shapes (2,2) (1,3) 

>à¦¯à¦¦à¦¿ à¦à¦•à¦œà¦¨ à¦›à¦¾à¦¤à§à¦° à¦¦à§à¦Ÿà¦¿ à¦¬à¦¿à¦·à¦¯à¦¼à§‡ à¦¨à¦®à§à¦¬à¦° à¦ªà¦¾à¦¯à¦¼ à¦†à¦° à¦†à¦°à§‡à¦•à¦œà¦¨ à¦¤à¦¿à¦¨à¦Ÿà¦¿à¦¤à§‡ à¦¦à§‡à¦¯à¦¼, à¦¤à¦¾à¦¹à¦²à§‡ à¦à¦•à¦¸à¦¾à¦¥à§‡ à¦—à§à¦£ à¦•à¦°à¦¾ à¦¸à¦®à§à¦­à¦¬ à¦¨à¦¯à¦¼à¥¤
Explanation:
Each cell of one matrix must match exactly with a cell in the other. It's like multiplying each studentâ€™s score with subject weights â€” only possible when all subjects match.

----------------------------------------------------------------------------------------------------------------------------------------------

## âœ… 5. Dot Product of Vectors :
Dot product requires same length vectors.

A = np.array([1, 2, 3])
B = np.array([4, 5])
print(np.dot(A, B))  # Error

Result =>

---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
<ipython-input-33-c55cf019d35f> in <cell line: 0>()
      1 A = np.array([1, 2, 3])
      2 B = np.array([4, 5])
----> 3 print(np.dot(A, B))  # Error
ValueError: shapes (3,) and (2,) not aligned: 3 (dim 0) != 2 (dim 0)

>à¦¤à§à¦®à¦¿ à¦¯à¦¦à¦¿ à¦¤à¦¿à¦¨à¦Ÿà¦¾ à¦¸à¦¿à¦¨à§‡à¦®à¦¾ à¦°à§‡à¦Ÿ à¦•à¦°à§‹ à¦†à¦° à¦†à¦®à¦¿ à¦¯à¦¦à¦¿ à¦¦à§à¦Ÿà§‹ à¦•à¦°à¦¿, à¦¤à¦¾à¦¹à¦²à§‡ similarity à¦¹à¦¿à¦¸à¦¾à¦¬ à¦•à¦°à¦¾ à¦¯à¦¾à¦¬à§‡ à¦¨à¦¾à¥¤
Explanation:
Dot product means multiplying matching items and then adding the results. If one vector is too short, the matching breaks.

----------------------------------------------------------------------------------------------------------------------------------------------

A = np.array([[1, 2]])
B = np.array([[3, 4]])
print(np.dot(A, B))  # Error

Result =>

---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
<ipython-input-37-53e21dd76639> in <cell line: 0>()
      1 A = np.array([[1, 2]])
      2 B = np.array([[3, 4]])
----> 3 print(np.dot(A, B))  # Error
ValueError: shapes (1,2) and (1,2) not aligned: 2 (dim 1) != 1 (dim 0)

>à¦¤à§à¦®à¦¿ à¦¯à¦¦à¦¿ à¦¤à¦¿à¦¨à¦Ÿà¦¾ à¦ªà§à¦°à¦¶à§à¦¨ à¦•à¦°à§‹ à¦†à¦° à¦†à¦®à¦¿ à¦¯à¦¦à¦¿ à¦¶à§à¦§à§ à¦¦à§à¦Ÿà§‹ à¦‰à¦¤à§à¦¤à¦° à¦¦à¦¿à¦‡, à¦¤à¦¾à¦¹à¦²à§‡ à¦ªà§à¦°à§‹ à¦ªà§à¦°à¦¶à§à¦¨à¦ªà¦¤à§à¦°à§‡à¦° à¦®à§‚à¦²à§à¦¯à¦¾à¦¯à¦¼à¦¨ à¦¸à¦®à§à¦­à¦¬ à¦¨à¦¯à¦¼à¥¤
Explanation:
Matrix multiplication takes the dot product of Aâ€™s row and Bâ€™s column. They must have matching lengths.

----------------------------------------------------------------------------------------------------------------------------------------------

| **Operation**                          | **Rule You Must Follow**            | âœ… **Works When...**            | âŒ **Fails When...**                 |
| -------------------------------------- | ----------------------------------- | ------------------------------ | ----------------------------------- |
| **Vector Addition**                    | Vectors must be same length         | `[1, 2, 3] + [4, 5, 6]`        | `[1, 2, 3] + [4, 5]`                |
| **Matrix Addition**                    | Same shape: rows and columns        | `2x2 + 2x2`                    | `2x2 + 1x3`                         |
| **Vector Element-wise Multiplication** | Same length                         | `[1, 2, 3] * [4, 5, 6]`        | `[1, 2, 3] * [4, 5]`                |
| **Matrix Element-wise Multiplication** | Same shape                          | `2x2 * 2x2`                    | `2x2 * 1x3`                         |
| **Vector Dot Product**                 | Vectors must be same length         | `np.dot([1, 2, 3], [4, 5, 6])` | `np.dot([1, 2, 3], [4, 5])`         |
| **Matrix Multiplication**              | Columns in A = Rows in B            | `np.dot(2x3, 3x2)`             | `np.dot(2x2, 1x2)`                  |

----------------------------------------------------------------------------------------------------------------------------------------------

a = np.array([4, 5, 6])
b = np.array([7, 8])

b_padded = np.pad(b, (0, len(a) - len(b)), constant_values=0)
print(a + b_padded)

Result =>

[11 13  6]

----------------------------------------------------------------------------------------------------------------------------------------------

min_len = min(len(a), len(b))
print(a[:min_len] + b[:min_len])

Result =>

[11 13]

----------------------------------------------------------------------------------------------------------------------------------------------
## ðŸ”§ 2. Matrix Addition or Element-wise Multiplication â€“ Shape Mismatch

A = np.array([[1, 2], [3, 4]])
B = np.array([[5, 6, 7]])
A + B  # ValueError

Result =>

---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
Cell In[14], line 3
      1 A = np.array([[1, 2], [3, 4]])
      2 B = np.array([[5, 6, 7]])
----> 3 A + B  # ValueError

ValueError: operands could not be broadcast together with shapes (2,2) (1,3) 

### âœ… Fix Option(s):

def pad_matrix(mat, target_shape, pad_value=0):
    padded = np.full(target_shape, pad_value)
    padded[:mat.shape[0], :mat.shape[1]] = mat
    return padded

A_fixed = pad_matrix(A, (2, 3))
B_fixed = pad_matrix(B, (2, 3))
print(A_fixed + B_fixed)

Result =>

[[6 8 7]
 [3 4 0]]
----------------------------------------------------------------------------------------------------------------------------------------------
